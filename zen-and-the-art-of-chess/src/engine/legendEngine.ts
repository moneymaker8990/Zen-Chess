// ============================================
// PLAY THE GREATS - LEGEND ENGINE
// 
// "Play the Greats" engine wrapper.
// Uses:
//  - Real opening book from the legend's games (first ~16 moves)
//  - Real positions → moves from their games (for midgame/middlegame positions)
//  - Falls back to humanized Stockfish engine when out of book / DB
//
// This gives you:
//  - In known positions: the bot literally plays *their exact move*.
//  - Elsewhere: human-looking, engine-backed moves.
//
// Assumes you have JSON files generated by parseLegendPGNs.ts:
//  - /data/legends/legend-fischer-opening-book.json
//  - /data/legends/legend-fischer-positions.json
//  - Same for capablanca, steinitz.
//
// Files should be in public/data/legends/ for browser access.
// ============================================

import { getHumanizedMove, BotLevel, getEngineCandidatesWithFeatures } from './humanizedStockfish';
import { type LegendId, type OpeningBookNode, type LegendPositionIndex, LEGEND_STYLES } from '@/lib/legendTypes';

// File paths (relative to public folder for browser)
// Make sure to copy the generated JSON files to public/data/legends/ after running the parser
const LEGENDS_DATA_PREFIX = '/data/legends';

// In-memory caches
let openingBooks: Partial<Record<LegendId, OpeningBookNode[]>> = {};
let positionIndices: Partial<Record<LegendId, LegendPositionIndex>> = {};
// Track which legends we've already warned about missing files
const missingFileWarnings = new Set<string>();

// Load data from JSON files
async function loadOpeningBook(legend: LegendId): Promise<OpeningBookNode[]> {
  if (openingBooks[legend]) return openingBooks[legend]!;
  
  try {
    const response = await fetch(`${LEGENDS_DATA_PREFIX}/legend-${legend}-opening-book.json`);
    if (!response.ok) {
      // File doesn't exist yet - this is expected if user hasn't run the parser
      return [];
    }
    const text = await response.text();
    // Check if we got HTML (404 page) instead of JSON
    if (text.trim().startsWith('<!')) {
      const warningKey = `opening-book-${legend}`;
      if (!missingFileWarnings.has(warningKey)) {
        console.warn(`Opening book file for ${legend} not found. Run the parser script to generate it.`);
        missingFileWarnings.add(warningKey);
      }
      return [];
    }
    const data = JSON.parse(text) as OpeningBookNode[];
    openingBooks[legend] = data;
    return data;
  } catch (err) {
    // Silently fail - file doesn't exist yet or isn't valid JSON
    return [];
  }
}

async function loadPositionIndex(legend: LegendId): Promise<LegendPositionIndex> {
  if (positionIndices[legend]) {
    const count = Object.keys(positionIndices[legend]!).length;
    console.log(`[${legend}] Position index already loaded: ${count} positions`);
    return positionIndices[legend]!;
  }
  
  try {
    const url = `${LEGENDS_DATA_PREFIX}/legend-${legend}-positions.json`;
    console.log(`[${legend}] Loading position index from: ${url}`);
    const response = await fetch(url);
    if (!response.ok) {
      console.error(`[${legend}] Failed to load position index: ${response.status} ${response.statusText}`);
      return {};
    }
    const text = await response.text();
    // Check if we got HTML (404 page) instead of JSON
    if (text.trim().startsWith('<!')) {
      const warningKey = `position-index-${legend}`;
      if (!missingFileWarnings.has(warningKey)) {
        console.error(`[${legend}] Position index file not found (got HTML). Run the parser script to generate it.`);
        missingFileWarnings.add(warningKey);
      }
      return {};
    }
    const data = JSON.parse(text) as LegendPositionIndex;
    const positionCount = Object.keys(data).length;
    positionIndices[legend] = data;
    console.log(`[${legend}] ✓ Position index loaded: ${positionCount} unique positions`);
    
    // Count total entries
    let totalEntries = 0;
    for (const entries of Object.values(data)) {
      if (Array.isArray(entries)) {
        totalEntries += entries.length;
      }
    }
    console.log(`[${legend}] ✓ Total position entries: ${totalEntries}`);
    
    return data;
  } catch (err) {
    console.error(`[${legend}] Error loading position index:`, err);
    return {};
  }
}

// Extract fullmove number from FEN (6th field, 1-based)
function getFullmoveNumberFromFen(fen: string): number {
  const parts = fen.trim().split(/\s+/);
  if (parts.length < 6) return 1;
  const fullmoveStr = parts[5];
  const n = parseInt(fullmoveStr, 10);
  return Number.isNaN(n) ? 1 : n;
}

// Weighted random choice
function pickWeighted<T>(items: T[], weights: number[]): T | null {
  if (items.length === 0 || items.length !== weights.length) return null;
  const total = weights.reduce((sum, w) => sum + w, 0);
  if (total <= 0) return items[0] || null;

  let r = Math.random() * total;
  for (let i = 0; i < items.length; i++) {
    r -= weights[i];
    if (r <= 0) return items[i];
  }
  return items[items.length - 1] || null;
}

// Get opening book move if available
async function getLegendBookMove(fen: string, legend: LegendId): Promise<string | null> {
  const book = await loadOpeningBook(legend);
  const candidates = book.filter((b) => b.fen === fen);
  if (candidates.length === 0) return null;

  // Weighted by frequency
  const weights = candidates.map((c) => c.count);
  const picked = pickWeighted(candidates, weights);
  return picked ? picked.move : null;
}

// Get their real move from a known position
async function getLegendDbMove(fen: string, legend: LegendId): Promise<string | null> {
  const index = await loadPositionIndex(legend);
  
  if (Object.keys(index).length === 0) {
    console.warn(`[${legend}] Position index is empty! Check if file loaded correctly.`);
    return null;
  }
  
  // Normalize FEN for comparison (remove move counters - they don't affect position)
  const normalizedFen = normalizeFenForComparison(fen);
  
  // Try exact match first
  let entries = index[fen];
  
  // If no exact match, try normalized match
  if (!entries || entries.length === 0) {
    // Look for any position with matching normalized FEN
    for (const [posFen, posEntries] of Object.entries(index)) {
      if (normalizeFenForComparison(posFen) === normalizedFen) {
        entries = posEntries;
        console.log(`[${legend}] Found normalized match for FEN (exact match failed)`);
        break;
      }
    }
  }
  
  if (!entries || entries.length === 0) {
    // Debug: show sample FENs from index to help diagnose matching issues
    const sampleFens = Object.keys(index).slice(0, 3);
    console.log(`[${legend}] No match found. Looking for: ${fen.substring(0, 50)}...`);
    console.log(`[${legend}] Sample FENs in index:`, sampleFens.map(f => f.substring(0, 50) + '...'));
    return null;
  }

  // Group by move → count
  const moveToCount = new Map<string, number>();
  for (const entry of entries) {
    const prev = moveToCount.get(entry.move) ?? 0;
    moveToCount.set(entry.move, prev + 1);
  }

  const moves = Array.from(moveToCount.keys());
  const counts = moves.map((m) => moveToCount.get(m) ?? 1);

  const pickedMove = pickWeighted(moves, counts);
  return pickedMove ?? null;
}

// Find similar positions by comparing FEN without move counters (for transpositions)
function normalizeFenForComparison(fen: string): string {
  // Remove move counters and castling rights to find similar positions
  const parts = fen.trim().split(/\s+/);
  return parts.slice(0, 4).join(' '); // Just position, turn, castling, en passant
}

// Try to find a similar position from the legend's games
async function findSimilarLegendMove(fen: string, legend: LegendId): Promise<string | null> {
  const index = await loadPositionIndex(legend);
  const targetNormalized = normalizeFenForComparison(fen);
  
  // Check for exact match first
  if (index[fen]) {
    return getLegendDbMove(fen, legend);
  }
  
  // Look for ALL positions with same normalized FEN (transpositions)
  // Combine all similar positions to get the best move based on what legend played most often
  const allSimilarEntries: any[] = [];
  for (const [posFen, entries] of Object.entries(index)) {
    if (!entries || !Array.isArray(entries)) continue;
    const normalized = normalizeFenForComparison(posFen);
    if (normalized === targetNormalized && entries.length > 0) {
      // Add all entries from all similar positions
      allSimilarEntries.push(...entries);
    }
  }
  
  if (allSimilarEntries.length === 0) return null;
  
  // Group ALL moves from ALL similar positions and weight by frequency
  // This ensures we pick the move the legend played most often in similar positions
  const moveToCount = new Map<string, number>();
  for (const entry of allSimilarEntries) {
    if (!entry || !entry.move) continue;
    const prev = moveToCount.get(entry.move) ?? 0;
    moveToCount.set(entry.move, prev + 1);
  }
  
  const moves = Array.from(moveToCount.keys());
  const counts = moves.map((m) => moveToCount.get(m) ?? 1);
  
  // Return the most frequently played move (what legend actually played most often)
  return pickWeighted(moves, counts);
}

// Apply legend style to engine candidates
function applyLegendStyle(
  candidates: Array<{
    move: string;
    scoreCp: number;
    features: {
      isCapture: boolean;
      isCheck: boolean;
      changesMaterial: number;
      kingExposureChange: number;
      simplifies: boolean;
    };
  }>,
  legend: LegendId
): string {
  const style = LEGEND_STYLES[legend];
  
  // Calculate adjusted scores based on legend style
  const adjusted = candidates.map(c => {
    let styleBoost = 0;
    
    // Aggressiveness: prefer checks and captures
    if (c.features.isCheck) {
      styleBoost += style.aggressiveness * 20;
    }
    if (c.features.isCapture) {
      styleBoost += style.aggressiveness * 15;
    }
    if (c.features.changesMaterial > 0) {
      styleBoost += style.aggressiveness * 10;
    }
    
    // Simplify bias: prefer exchanges and endgame positions
    if (c.features.simplifies) {
      styleBoost += style.simplifyBias * 12;
    }
    
    // King safety: avoid risky moves
    if (c.features.kingExposureChange > 0) {
      styleBoost -= style.kingSafetyBias * c.features.kingExposureChange;
    }
    
    // Materialism: willingness to sacrifice
    if (c.features.changesMaterial < 0) {
      // Sacrifice - only if low materialism
      styleBoost += (1 - style.materialism) * Math.abs(c.features.changesMaterial) * 8;
    }
    
    return {
      ...c,
      adjustedScore: c.scoreCp + styleBoost,
    };
  });
  
  // Sort by adjusted score
  adjusted.sort((a, b) => b.adjustedScore - a.adjustedScore);
  
  // Pick top move with small chance of second/third for variety
  const top = adjusted[0];
  if (!top) return candidates[0]?.move || '';
  
  // 70% chance for top move, 20% for second, 10% for third
  const roll = Math.random();
  if (roll < 0.7 || adjusted.length === 1) {
    return top.move;
  } else if (roll < 0.9 && adjusted.length >= 2) {
    return adjusted[1].move;
  } else if (adjusted.length >= 3) {
    return adjusted[2].move;
  }
  
  return top.move;
}

/**
 * Get a move from a legend bot - AUTHENTIC VERSION
 * 
 * Priority order for maximum authenticity:
 * 1. Real opening book moves (first ~16 moves) - 100% use their real move
 * 2. Real moves from known positions - 100% use their real move
 * 3. Similar positions (transpositions) - 80% use similar position's move
 * 4. Style-biased engine fallback - applies legend's playing style
 * 
 * This prioritizes authenticity: when we have their actual moves, we ALWAYS use them.
 * Only when completely novel do we use a style-biased engine.
 */
export async function getLegendMove(params: {
  fen: string;
  moves: string[];
  legend: LegendId;
  level?: BotLevel;
}): Promise<string> {
  const { fen, moves, legend, level: _level = 'coach' } = params; // Legends play at maximum strength

  const fullmoveNumber = getFullmoveNumberFromFen(fen);

  // 1) OPENING: Use their real opening moves 100% of the time
  if (fullmoveNumber <= 16) {
    const bookMove = await getLegendBookMove(fen, legend);
    if (bookMove) {
      console.log(`[${legend}] Using opening book move: ${bookMove}`);
      return bookMove; // Always use their real opening move
    }
  }

  // 2) KNOWN POSITIONS: Use their exact move 100% of the time
  const dbMove = await getLegendDbMove(fen, legend);
  if (dbMove) {
    console.log(`[${legend}] Using real move from database: ${dbMove}`);
    return dbMove; // Always replay their actual move
  }

  // 3) SIMILAR POSITIONS: Try to find transpositions or similar positions
  // ALWAYS use real moves when found - 100% authenticity
  const similarMove = await findSimilarLegendMove(fen, legend);
  if (similarMove) {
    console.log(`[${legend}] Using similar position move: ${similarMove}`);
    return similarMove; // 100% use their real move from similar position
  }

  console.warn(`[${legend}] No real move found for position, using engine fallback`);

  // 4) STYLE-BIASED ENGINE FALLBACK: Apply legend's playing style
  // Get multiple candidate moves and apply style preferences
  // Always use maximum strength ('coach') for legends
  try {
    const candidates = await getEngineCandidatesWithFeatures({
      fen,
      moves,
      level: 'coach', // Maximum strength for legends
      maxCandidates: 5,
    });
    
    if (candidates.length > 0) {
      return applyLegendStyle(candidates, legend);
    }
  } catch (err) {
    console.warn('Error getting styled candidates, falling back to basic engine:', err);
  }

  // Final fallback: basic humanized move at maximum strength
  return getHumanizedMove({
    fen,
    moves,
    level: 'coach', // Maximum strength for legends
  });
}

/**
 * Get a specific game by ID
 */
export async function getLegendGame(legend: LegendId, gameId: string): Promise<any | null> {
  try {
    const response = await fetch(`${LEGENDS_DATA_PREFIX}/legend-${legend}-games.json`);
    if (!response.ok) return null;
    
    const games = await response.json();
    return games.find((g: any) => g.id === gameId) || null;
  } catch (err) {
    console.error('Error loading legend game:', err);
    return null;
  }
}

/**
 * Get all games for a legend
 */
export async function getLegendGames(legend: LegendId): Promise<any[]> {
  try {
    const response = await fetch(`${LEGENDS_DATA_PREFIX}/legend-${legend}-games.json`);
    if (!response.ok) return [];
    
    const text = await response.text();
    // Check if we got HTML (404 page) instead of JSON
    if (text.trim().startsWith('<!')) {
      const warningKey = `games-${legend}`;
      if (!missingFileWarnings.has(warningKey)) {
        console.warn(`Games file for ${legend} not found. Run the parser script to generate it.`);
        missingFileWarnings.add(warningKey);
      }
      return [];
    }
    
    return JSON.parse(text);
  } catch (err) {
    // Silently fail - file doesn't exist yet
    return [];
  }
}


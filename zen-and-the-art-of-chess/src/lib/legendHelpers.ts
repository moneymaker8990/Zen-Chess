// Helper functions for working with legend data
// Generated by parseLegendPGNs.ts script

import { Chess } from 'chess.js';
import { logger } from './logger';
import type {
  LegendId,
  LegendGame,
  OpeningBookNode,
  LegendPosition,
  LegendPositionIndex,
} from './legendTypes';

export type GuessSession = {
  gameId: string;
  positions: Array<{
    fen: string;
    correctMove: string; // UCI
    moveNumber: number;
    userGuess?: string;
    isCorrect?: boolean;
  }>;
  currentIndex: number;
  score: number;
};

// Cache for loaded data
const openingBookCache = new Map<LegendId, OpeningBookNode[]>();
const positionIndexCache = new Map<LegendId, LegendPositionIndex>();
const gamesCache = new Map<LegendId, LegendGame[]>();

/**
 * Load opening book data for a legend
 */
async function loadOpeningBook(legend: LegendId): Promise<OpeningBookNode[]> {
  if (openingBookCache.has(legend)) {
    return openingBookCache.get(legend)!;
  }

  try {
    const response = await fetch(`/data/legends/legend-${legend}-opening-book.json`);
    const data = await response.json();
    openingBookCache.set(legend, data);
    return data;
  } catch (err) {
    logger.error(`Failed to load opening book for ${legend}:`, err);
    return [];
  }
}

/**
 * Load position index for a legend
 */
async function loadPositionIndex(legend: LegendId): Promise<LegendPositionIndex> {
  if (positionIndexCache.has(legend)) {
    return positionIndexCache.get(legend)!;
  }

  try {
    const response = await fetch(`/data/legends/legend-${legend}-positions.json`);
    const data = await response.json();
    positionIndexCache.set(legend, data);
    return data;
  } catch (err) {
    logger.error(`Failed to load position index for ${legend}:`, err);
    return {};
  }
}

/**
 * Load games for a legend
 */
async function loadGames(legend: LegendId): Promise<LegendGame[]> {
  if (gamesCache.has(legend)) {
    return gamesCache.get(legend)!;
  }

  try {
    const response = await fetch(`/data/legends/legend-${legend}-games.json`);
    const data = await response.json();
    gamesCache.set(legend, data);
    return data;
  } catch (err) {
    logger.error(`Failed to load games for ${legend}:`, err);
    return [];
  }
}

/**
 * Convert SAN move to UCI format using chess.js
 */
function sanToUci(fen: string, sanMove: string): string | null {
  try {
    const chess = new Chess(fen);
    const move = chess.move(sanMove);
    if (!move) return null;
    return move.from + move.to + (move.promotion || '');
  } catch {
    return null;
  }
}

/**
 * Get a move from the legend's opening book based on current position
 * Returns null if position is not in book
 * Returns move in UCI format
 */
export async function getLegendBookMove(
  legend: LegendId,
  fen: string
): Promise<string | null> {
  const openingBook = await loadOpeningBook(legend);
  
  // Find all moves from this position
  const candidates = openingBook.filter(entry => entry.fen === fen);
  
  if (candidates.length === 0) {
    return null; // Not in book
  }

  // Weight selection by frequency (more common moves more likely)
  const total = candidates.reduce((sum, c) => sum + c.count, 0);
  const rand = Math.random() * total;
  
  let accumulated = 0;
  for (const candidate of candidates) {
    accumulated += candidate.count;
    if (rand <= accumulated) {
      // Convert SAN to UCI if needed
      const move = candidate.move;
      // Check if it's already UCI (4-5 chars, all lowercase/numbers)
      if (/^[a-h][1-8][a-h][1-8][qrbn]?$/.test(move)) {
        return move; // Already UCI
      }
      // Otherwise convert from SAN
      return sanToUci(fen, move) || move;
    }
  }
  
  // Fallback to most common move
  const fallbackMove = candidates[0].move;
  if (/^[a-h][1-8][a-h][1-8][qrbn]?$/.test(fallbackMove)) {
    return fallbackMove; // Already UCI
  }
  return sanToUci(fen, fallbackMove) || fallbackMove;
}

/**
 * Get a random position from the legend's games for Guess-the-Move
 */
export async function getRandomLegendPosition(
  legend: LegendId,
  options?: {
    minMoveNumber?: number;
    maxMoveNumber?: number;
    color?: 'w' | 'b';
  }
): Promise<LegendPosition | null> {
  const positionIndex = await loadPositionIndex(legend);
  const fens = Object.keys(positionIndex);
  
  if (fens.length === 0) {
    return null;
  }

  // Filter positions by options
  if (options) {
    const allPositions: LegendPosition[] = [];
    fens.forEach(fen => {
      positionIndex[fen].forEach(pos => {
        if (
          (!options.minMoveNumber || pos.moveNumber >= options.minMoveNumber) &&
          (!options.maxMoveNumber || pos.moveNumber <= options.maxMoveNumber) &&
          (!options.color || pos.color === options.color)
        ) {
          allPositions.push(pos);
        }
      });
    });
    
    if (allPositions.length === 0) return null;
    const selected = allPositions[Math.floor(Math.random() * allPositions.length)];
    // Convert move to UCI if needed
    if (selected.move && !/^[a-h][1-8][a-h][1-8][qrbn]?$/.test(selected.move)) {
      const uciMove = sanToUci(selected.fen, selected.move);
      if (uciMove) {
        return { ...selected, move: uciMove };
      }
    }
    return selected;
  }

  // Pick random FEN, then random position at that FEN
  const randomFen = fens[Math.floor(Math.random() * fens.length)];
  const positionsAtFen = positionIndex[randomFen];
  const selected = positionsAtFen[Math.floor(Math.random() * positionsAtFen.length)];
  // Convert move to UCI if needed
  if (selected.move && !/^[a-h][1-8][a-h][1-8][qrbn]?$/.test(selected.move)) {
    const uciMove = sanToUci(selected.fen, selected.move);
    if (uciMove) {
      return { ...selected, move: uciMove };
    }
  }
  return selected;
}

/**
 * Create a Guess-the-Move session from a specific game
 */
export async function createGuessSessionFromGame(
  legend: LegendId,
  gameId: string
): Promise<GuessSession | null> {
  const games = await loadGames(legend);
  const game = games.find(g => g.id === gameId);
  
  if (!game) {
    return null;
  }

  const positionIndex = await loadPositionIndex(legend);
  
  // Find all positions from this game
  const gamePositions: LegendPosition[] = [];
  Object.values(positionIndex).forEach(positions => {
    positions.forEach(pos => {
      if (pos.gameId === gameId) {
        gamePositions.push(pos);
      }
    });
  });

  // Sort by move number
  gamePositions.sort((a, b) => a.moveNumber - b.moveNumber);

  return {
    gameId,
    positions: gamePositions.map(pos => {
      // Convert SAN to UCI if needed
      let correctMove = pos.move;
      if (correctMove && !/^[a-h][1-8][a-h][1-8][qrbn]?$/.test(correctMove)) {
        const uciMove = sanToUci(pos.fen, correctMove);
        if (uciMove) {
          correctMove = uciMove;
        }
      }
      return {
        fen: pos.fen,
        correctMove,
        moveNumber: pos.moveNumber,
      };
    }),
    currentIndex: 0,
    score: 0,
  };
}

/**
 * Get a random game from a legend
 */
export async function getRandomLegendGame(legend: LegendId): Promise<LegendGame | null> {
  const games = await loadGames(legend);
  if (games.length === 0) return null;
  return games[Math.floor(Math.random() * games.length)];
}

/**
 * Get all games for a legend
 */
export async function getAllLegendGames(legend: LegendId): Promise<LegendGame[]> {
  return loadGames(legend);
}

/**
 * Get statistics about a legend's data
 */
export async function getLegendStats(legend: LegendId): Promise<{
  totalGames: number;
  openingBookSize: number;
  uniquePositions: number;
  totalPositions: number;
}> {
  const [games, openingBook, positionIndex] = await Promise.all([
    loadGames(legend),
    loadOpeningBook(legend),
    loadPositionIndex(legend),
  ]);

  const totalPositions = Object.values(positionIndex).reduce(
    (sum, positions) => sum + positions.length,
    0
  );

  return {
    totalGames: games.length,
    openingBookSize: openingBook.length,
    uniquePositions: Object.keys(positionIndex).length,
    totalPositions,
  };
}

